import { WebGLUtility } from "../lib/webgl.js";
import VSSource from "./main.vert";
import FSSource from "./main.frag";
import Image1 from "./assets/001.jpg";
import Image2 from "./assets/002.jpg";
import Image3 from "./assets/003.jpg";
import Image4 from "./assets/004.jpg";
import Image5 from "./assets/005.jpg";
import Image6 from "./assets/006.jpg";
import Image7 from "./assets/007.jpg";
import Image8 from "./assets/008.jpg";

class Transition {
  static DURATION = 300.0;
  private is_transitioning = false;
  private time: number;
  private startTime: number | undefined;
  private onTransitionEnd: () => void;
  constructor(onTransitionEnd: () => void) {
    this.time = performance.now();
    this.onTransitionEnd = onTransitionEnd;
  }
  get isTransitioning() {
    return this.is_transitioning;
  }
  startTransition() {
    this.is_transitioning = true;
    this.startTime = performance.now();
  }
  update() {
    this.time = performance.now();
    if (this.startTime && this.time - this.startTime > Transition.DURATION) {
      this.is_transitioning = false;
      this.startTime = undefined;
      this.onTransitionEnd();
    }
  }
  getProgress() {
    if (!this.startTime) {
      return 0.0;
    }
    return Math.min((this.time - this.startTime) / Transition.DURATION, 1.0);
  }
}

// generated by ChatGPT
const padImageToPowerOfTwo = async (image: HTMLImageElement) => {
  const originalWidth = image.width;
  const originalHeight = image.height;

  // 2のべき乗のサイズに丸める
  const width = Math.pow(2, Math.ceil(Math.log2(originalWidth)));
  const height = Math.pow(2, Math.ceil(Math.log2(originalHeight)));

  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;

  const ctx = canvas.getContext("2d")!;
  ctx.drawImage(image, 0, 0, originalWidth, originalHeight);
  const imageUrl = canvas.toDataURL();
  return (await WebGLUtility.loadImage(imageUrl)) as HTMLImageElement;
};

window.addEventListener(
  "DOMContentLoaded",
  async () => {
    const app = new App();
    app.init();
    await app.load();
    app.setupGeometry();
    app.setupLocation();
    app.setupEventHandler();
    app.start();
  },
  false,
);

class App {
  canvas: HTMLCanvasElement;
  gl: WebGLRenderingContext;
  textures: WebGLTexture[];
  // WebGL 2.0ではuniformとして渡さなくても良くなるらしい？
  textureSizes: Float32Array[];
  originalImageSizes: Float32Array[];
  program: WebGLProgram;
  attributeLocation: GLint[];
  attributeStride: GLint[];
  planePoints: number[];
  planeVBO: WebGLBuffer;
  uniformLocation: {
    progress: WebGLUniformLocation;
    resolution: WebGLUniformLocation;
    texture0: WebGLUniformLocation;
    texSize0: WebGLUniformLocation;
    originalImageSize0: WebGLUniformLocation;
    texture1: WebGLUniformLocation;
    texSize1: WebGLUniformLocation;
    originalImageSize1: WebGLUniformLocation;
  };
  imageIndex = 0;
  nextImageIndex = -1;
  transition: Transition;
  touchEventTrigerred = false;

  constructor() {
    // this を固定するためのバインド処理
    this.resize = this.resize.bind(this);
    this.render = this.render.bind(this);
  }

  init() {
    this.canvas = document.getElementById("webgl-canvas") as HTMLCanvasElement;
    this.gl = WebGLUtility.createWebGLContext(this.canvas);

    this.resize();

    window.addEventListener("resize", this.resize, false);

    this.gl.enable(this.gl.CULL_FACE);
    this.gl.enable(this.gl.DEPTH_TEST);
  }

  onTransitionEnd() {
    this.imageIndex = this.nextImageIndex;
    this.nextImageIndex = this.getNextImageIndex();
  }

  getNextImageIndex() {
    while (true) {
      const next = Math.floor(Math.random() * this.textures.length);
      if (next !== this.imageIndex) {
        return next;
      }
    }
  }

  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  async load() {
    const gl = this.gl;
    if (!gl) {
      throw new Error("not initialized");
    }

    // vertex shader
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    if (!vertexShader) {
      throw new Error("failed to create vertex shader");
    }
    gl.shaderSource(vertexShader, VSSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(vertexShader)!);
    }

    // fragment shader
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    if (!fragmentShader) {
      throw new Error("failed to create fragment shader");
    }
    gl.shaderSource(fragmentShader, FSSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(fragmentShader)!);
    }

    // load images
    const images: HTMLImageElement[] = await Promise.all([
      WebGLUtility.loadImage(Image1),
      WebGLUtility.loadImage(Image2),
      WebGLUtility.loadImage(Image3),
      WebGLUtility.loadImage(Image4),
      WebGLUtility.loadImage(Image5),
      WebGLUtility.loadImage(Image6),
      WebGLUtility.loadImage(Image7),
      WebGLUtility.loadImage(Image8),
    ]);
    const resizedImages = await Promise.all<HTMLImageElement>(
      images.map((img) => padImageToPowerOfTwo(img)),
    );
    this.textures = resizedImages.map((img) =>
      WebGLUtility.createTexture(gl, img),
    );
    const textureSizes: Float32Array[] = [];
    const originalImageSizes: Float32Array[] = [];
    for (const i in resizedImages) {
      const originalImg = images[i];
      const resizedImg = resizedImages[i];
      textureSizes.push(
        new Float32Array([resizedImg.width, resizedImg.height]),
      );
      originalImageSizes.push(
        new Float32Array([originalImg.width, originalImg.height]),
      );
    }
    this.originalImageSizes = originalImageSizes;
    this.textureSizes = textureSizes;

    // compile program
    const program = gl.createProgram();
    if (!program) {
      throw new Error("failed to create webgl program");
    }
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(gl.getProgramInfoLog(program)!);
    }
    gl.useProgram(program);
    this.program = program;
  }

  setupGeometry() {
    const gl = this.gl;
    const [sy, sx, gy, gx] = [-1, -1, 1, 1];
    const cs0 = [
      sx,
      sy,
      0,
      gx,
      gy,
      0,
      sx,
      gy,
      0,
      gx,
      gy,
      0,
      sx,
      sy,
      0,
      gx,
      sy,
      0,
    ];
    const planeVBO = gl.createBuffer()!;
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVBO);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cs0), gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    this.planeVBO = planeVBO;
    this.planePoints = cs0;
  }

  setupLocation() {
    const gl = this.gl;
    this.attributeLocation = [gl.getAttribLocation(this.program, "position")];
    this.attributeStride = [3];
    // uniform location の取得
    // TODO texture1
    this.uniformLocation = {
      progress: gl.getUniformLocation(this.program, "progress")!,
      resolution: gl.getUniformLocation(this.program, "resolution")!,
      texture0: gl.getUniformLocation(this.program, "texture0")!,
      texSize0: gl.getUniformLocation(this.program, "texSize0")!,
      originalImageSize0: gl.getUniformLocation(
        this.program,
        "originalImageSize0",
      )!,

      texture1: gl.getUniformLocation(this.program, "texture1")!,
      texSize1: gl.getUniformLocation(this.program, "texSize1")!,
      originalImageSize1: gl.getUniformLocation(
        this.program,
        "originalImageSize1",
      )!,
    };
  }

  setupEventHandler() {
    const onTouch = () => {
      if (this.transition.isTransitioning) {
        return;
      }
      this.transition.startTransition();
    };

    window.addEventListener("touchend", (_) => {
      this.touchEventTrigerred = true;
      onTouch();
    });
    window.addEventListener("click", (_) => {
      if (this.touchEventTrigerred) {
        this.touchEventTrigerred = false;
        return;
      }
      onTouch();
    });
    this.transition = new Transition(() => {
      this.onTransitionEnd();
    });
  }

  setupRendering() {
    const gl = this.gl;
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    gl.clearColor(0.3, 0.3, 0.3, 1.0);
    gl.clearDepth(1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  }

  start() {
    this.nextImageIndex = this.getNextImageIndex();
    this.render();
  }

  render() {
    const gl = this.gl;
    // 現在の画像はTEXTUE0、次の画像はTEXTURE1で管理
    const i = this.imageIndex;
    const j = this.nextImageIndex;

    const progress = this.transition.getProgress();
    this.setupRendering();

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.textures[i]);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, this.textures[j]);

    gl.useProgram(this.program);
    gl.uniform1f(this.uniformLocation.progress, progress);
    gl.uniform2f(
      this.uniformLocation.resolution,
      this.canvas.width,
      this.canvas.height,
    );
    gl.uniform1i(this.uniformLocation.texture0, 0);
    gl.uniform2fv(this.uniformLocation.texSize0, this.textureSizes[i]);
    gl.uniform2fv(
      this.uniformLocation.originalImageSize0,
      this.originalImageSizes[i],
    );

    gl.uniform1i(this.uniformLocation.texture1, 1);
    gl.uniform2fv(this.uniformLocation.texSize1, this.textureSizes[j]);
    gl.uniform2fv(
      this.uniformLocation.originalImageSize1,
      this.originalImageSizes[j],
    );

    // configure VBO
    gl.bindBuffer(gl.ARRAY_BUFFER, this.planeVBO);
    gl.enableVertexAttribArray(this.attributeLocation[0]);
    gl.vertexAttribPointer(
      this.attributeLocation[0],
      this.attributeStride[0],
      gl.FLOAT,
      false,
      0,
      0,
    );
    gl.drawArrays(
      gl.TRIANGLES,
      0,
      this.planePoints.length / this.attributeStride[0],
    );
    // 描画前に呼ぶとちらつく
    this.transition.update();
    requestAnimationFrame(this.render);
  }
}
